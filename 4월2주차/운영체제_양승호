# 운영체제

교착상태(DeadLock)

---

**1. 교착상태란**  
프로세스나 스레드가 결코 일어날 수 없는 특정 이벤트를 기다리는 상태



![title](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbPJIyW%2FbtrzOHSkGlQ%2FkMjcLMkKrbYpXbWxWYKiFK%2Fimg.jpg)      
   
프로세스 1은 자원 A를 필요로 하고, 자원A는 프로세스 2가 점유하고 있음  
프로세스 2는 자원 B를 필요로 하고, 자원B는 프로세스 1이 점유하고 있음  
위와 같은 상태에서 두 프로세스 중 어느 한 프로세스가 자원을 양보하지 않는 이상 그 누구도 작업을 수행할 수 없는 상태

**2. 교착상태의 발생 조건**  

- 상호 배제
  - 한 자원은 한 번에 한 프로세스만 사용가능
- 점유와 대기
  - 한 프로세스가 1개 이상의 자원을 점유하면서 다른 프로세스가 해당 리소스를 사용대기중
- 비선점
  - 프로세스가 작업을 마친 후 자발적으로 반환할때까지 기다림
- 순환 대기
  - 두 개 이상의 프로세스가 원형구조로 다른 프로세스가 점유하고 있는 자원을 요구하는 상태


위 4가지 중 하나라도 만족하지 않으면 교착상태는 발생하지 않음  

  
**3. 대처방안**   
   
1. 예방 : 교착상태가 발생할 수 있는 요구조건을 미연에 방지하는 방법
2. 회피 : 교착상태가 발생할 가능성이 있는 자원할당을 하지 않는다
3. 회복 : 발생하도록 둔 후 발생 후 찾아서 해결한다  


**3.1.1 상호배제 조건 방지**  
- 상호배제 조건을 방지하려면 자원이 여러 프로세스가 동시에 사용할 수 있어야하지만, 자원은 기본적으로 공유가 불가능하므로 해당방법으로 교착상태를 예방하는 것은 사실상 어려움  

**3.1.2 점유와 대기 방지**  
- 프로세스가 실행되기 전에 모든 자원을 할당하거나, 자원이 점유되지 않은 상태에서만 요청을 받도록 함  

**3.1.3 비선점 방지**
- 선점 방식 사용

**3.1.4 순환 대기 방지**
- 자원에 고유한 번호를 할당한 후, 번호 순으로 자원을 요구하도록 함


---

**3.2.1 교착상태 회피 조건**  
- 프로세스 수가 고정되어 있어야 함
- 자원의 종류와 수가 고정되어 있어야 함
- 프로세스가 요구하는 자원과 최대 자원수를 알아야 함
- 프로세스는 자원을 사용후에 반납해야 함  

**3.2.2 은행원 알고리즘**  
은행원 알고리즘을 통해 Safe satate, Unsate state를 판별

시스템은 12개의 자원을 가지고 있는 상태
| | 최대 자원요청량 | 할당중인 자원량 | 남은 필요한 자원의 양 |
| --- | --- | --- | --- |
| P0 | 10 | 5 | 5 |
| P1 | 4 | 2 | 2 |
| P2 | 9 | 2 | 7 |  

- 남은 가용자원 3개를 P1에게 할당 => 가용자원은 3 - 2 = 1
- P1의 작업이 끝나고 할당되어 있던 자원  4개 반납 => 가용자원은 1 + 4 = 5
- 남은 가용자원 5개를 P0에게 할당 => 가용자원은 5 - 5 = 0
- P0의 작업이 끝나고 할당되어 있던 자원 10개 반납 => 가용자원은 0 + 10 = 10
- 남은 가용자원 10개 중 7개를 P2에게 할당 => 가용자원은 10 - 7 = 3
- P2의 작업이 끝나고 할당되어 있던 자원 9개 반납 => 가용자원은 3 + 9 = 12  

---



**3.3.1 프로세스 중지**  
- 교착상태의 모든 프로세스를 중지
- 교착상태가 해결될 때까지 한 프로세스씩 중지   

**3.3.2 자원선점**
- 프로세스로부터 자원을 빼앗아 교착상태가 해결될 때까지 다른 프로세스에게 할당
