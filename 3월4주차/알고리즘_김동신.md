## 알고리즘 관련 질문

#### 1. DFS vs BFS

##### 공통점

- 그래프 자료구조를 탐색하는 방법
- 모든 노드를 검색할 때, 시간복잡도는 O(V+E) (V는 정점의 수, E는 간선의 수)
  - 인접리스트로 사용했을 때이며, 인접 행렬일 경우 O(N^2)를 가지므로 비효율적임

##### 차이점

|               | DFS                                                          | BFS                                                          |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 탐색 방법     | 시작 정점에서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식<br />- 더 이상 한 방향으로 탐색할 수 없을 때까지 탐색<br />- 더 이상 탐색할 수 없을 때, 가장 가까운 갈림길로 돌아와 다른 방향 탐색 | 시작 정점과 인접한 노드를 먼저 탐색하는 방식<br />- 시작 정점으로부터 가장 가까운 정점을 먼저 방문하고, 멀리 있는 정점은 나중에 방문 |
| 사용되는 경우 | 1. 검색 대상의 그래프가 큰 경우<br />2. 한 경로의 특성을 저장하면서 탐색해야하는 경우 | 1. 검색 대상의 그래프가 작은 경우<br />2. 두 노드 사이의 최단 경로를 찾고 싶은 경우 |
| 구현 방법     | 스택, 재귀함수                                               | 큐                                                           |

- DFS 사용시 스택과 재귀함수의 차이

  - DFS에서 스택을 활용하는 경우가 재귀함수를 사용하는 경우보다 빠르다고 합니다.

    - 재귀의 경우, 함수를 호출하고 반환할 때마다 call stack 전체를 다뤄야하지만, stack은 단지 두 변수만 pop/push 하기 때문

    - 만약, 깊이가 매우 깊다고 가정을 한다면, 재귀의 경우 stack overflow로 인해 값을 반환하지 못한 채 프로그램이 종료될 것입니다. stack은 어떻게든 결과값을 반환할 것이고요.

      결과를 반환하지 않는 코드와, 시간 안에 결과를 반환해내는 코드의 성능 비교는 단연 후자가 더 좋다고 할 수 있을 것입니다.

    - 더 깊게 간다면, 재귀는 stack 영역에서, stack으로 구현한 경우, heap 영역에 저장됩니다.
      stack으로 구현한 경우 heap 영역이 고갈될 때까지는 결과를 반환할 수 있습니다.
      하지만, heap 영역은 stack 영역보다 수천배는 크기 때문에 그런 걱정은 필요가 없습니다.(window의 경우 stack 큭가 1mb)

  - **하지만**, **그 정도가 유의미한 차이가 아니랍니다.** 속도 때문에 어떤 방법으로 구현할지 고민하는 것은 무의미하다는 것!

  - 재귀로 구현하는 것 자체가 속도를 위한 것이 아닌 코드의 명확성,편리성을 위해서 재귀로 구현하는 것

  **결론 : 두 구현 방법 간 성능 차이는 무의미하다.**

  출처
  https://stackoverflow.com/questions/15684330/recursive-approach-versus-stack-for-depth-first-search 
  https://www.quora.com/Which-is-faster-implement-Depth-First-Search-using-recursive-function-calls-or-using-a-stack
  https://bentist.tistory.com/57
  https://insalat.tistory.com/10



#### 2. 피보나치를 구현하는 3가지 방법

1. 재귀함수

   ```python
   def fibo(x):
       if x==0 or x==1:
           return 1
       else:
           return fibo(x-2)+fibo(x-1)
   ```

   - 시간복잡도 : O(2^N)
     - N의 값이 커질수록 성능이 훨씬 안좋게 나옴

   

2. 반복문

   ```python
   def fibo(x):
       fibo_1, fibo_2 = 0, 1
   
       for i in range(x):
           fibo_1, fibo_2 = fibo_2, fibo_1 + fibo_2
       return fibo_1
   ```

   - 시간복잡도 : O(N)

   

3. DP

   ```python
   def fibo(x):
   	dp = [1]*x
       for i in range(2,x):
           dp[i] = dp[i-2]+dp[i-1]
       
       return dp[x-1]
   ```

   - 시간복잡도 : O(N)

   

<details>
<summary style="font-size: 16px; font-weight: bold;">2-1. 그렇다면 DP로 구현한 것과 반복문으로 구한 것의 차이는?</summary>
<div markdown="1">
  <ul>
      <li>DP로 구한 경우, 한번 값을 구하고 난 뒤에 다시 구할 때는 O(1)만에 구할 수 있음</li>
      <br>
      <li>즉, fibo(N)의 값을 한번 구하고 난 뒤에, N보다 작은 경우 역시도 O(1)만에 구할 수 있음</li>
  </ul> 
</div>
</details> 



#### 3. 안정 정렬 vs 불안정 정렬 (stable vs unstable)

- 특정 값 즉, key값을 기준으로 정렬 할 때, 같은 key값을 가진 요소들의 순서가 정렬 전과 후가 같은가?

- 예시 

  - 트럼프 카드 4장을 숫자 기준 오름차순으로 정렬한다고 하자

  ![img](https://t1.daumcdn.net/cfile/tistory/9957C8375C35A1411C)

##### 안정정렬

- 중복된 key값을 가진 요소들이 정렬 전 순서와 동일하게 정렬되는 정렬 알고리즘

- 종류 : 삽입정렬, 병합정렬, 버블정렬

- 예시

  ![img](https://t1.daumcdn.net/cfile/tistory/99D4AB375C35A14222)

  - 같은 key 값. 즉, 같은 숫자를 가진 4하트와 4스페이드가 정렬 전 순서와 동일 



##### 불안정 정렬

- 중복된 key값의 요소들이 정렬 전 순서와 동일하지 않게 정렬되는 알고리즘

- 종류 : 퀵정렬, 선택정렬, 계수정렬, 힙정렬

- 예시

  ![img](https://t1.daumcdn.net/cfile/tistory/99345A375C35A1431E)

  - 같은 key값. 즉, 같은 숫자를 가진 4하트와 4스페이드가 정렬 전 순서와 다름

이미지 출처 : https://godgod732.tistory.com/10



#### 4. 시간복잡도와 공간복잡도 설명

- 알고리즘 혹은 프로그램의 성능을 측정하는 두가지 척도
  - 보통 복잡도라고 하면 시간복잡도를 의미

- 복잡도를 표기하는 방법
  - 빅오메가(Big Ω) : 최선의 케이스를 나타내는 방법
  - 빅세타(Big Θ) : 가장 빠른 경우와 가장 느린 경우의 평균
  - 빅오(Big-O): 가장 최악의 경우(느린 경우)를 나타내는 방법
    - 보통 빅오 표기법을 사용
- 시간복잡도와 공간복잡도는 반비례적인 경향이 있음



##### 시간복잡도

- 알고리즘이 어떤 문제를 해결하는데 걸리는 시간
  - 입력값과 연산 수행 시간의 상관관계를 나타내는 척도
    - 즉, 입력의 크기에 따라 알고리즘이 얼마나 오래 걸리는지를 의미

##### 공간복잡도

- 작성한 프로그램이 얼마나 많은 메모리를 차지하는지에 대한 척도



<details>
<summary style="font-size: 16px; font-weight: bold;">4-1. 시간복잡도와 실제 수행 시간과의 관계</summary>
<div markdown="1">
  컴퓨터의 환경에 따라 실제 수행시간은 달라짐. <br>
  또한, 시간복잡도는 주로 빅오 표기법을 사용하기에 최악의 경우를 나타냄 <br>
  즉, 같은 알고리즘이어도 컴퓨터의 환경에 따라 실제 실행시간은 달라질 수 있으며, 입력값에 따라서도 달라질 수 있음 <br>
  또한, 빅오표기법을 작성할 때, 상수나 최고차항 이외의 항들은 모두 제외하고 근사치를 표기하기 때문에 실제 결과와는 다를 수 있음
</div>
</details> 

<details>
<summary style="font-size: 16px; font-weight: bold;">4-2. 최악일 때의 시간복잡도가 매우 큰데도 자주 사용되는 경우</summary>
<div markdown="1">
  <p style="font-weight:bold">퀵 소트</p>
  <p>
      퀵소트가 대표적인 예시 <br>
      정렬하고자 하는 대상이 이미 정렬되어 있는 경우 퀵소트는 최악일 때 시간 복잡도 O(n^2)을 가짐. <br>
      하지만, 평균적으로 O(nlogn)의 아주 좋은 시간복잡도를 가짐 <br>
      그래서 C, C++, PHP와 같은 프로그래밍 언어의 내장정렬 함수에서 사용됩니다. 
    </p>
    </div>
</details>
