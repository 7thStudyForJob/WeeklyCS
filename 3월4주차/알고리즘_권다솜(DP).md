# DP : Dynamic Programming(동적 계획법)

1. 탄생 배경

   : 완전 탐색, DFS, BFS와 같이 수많은 경우의 수를 전부 따져봐야 하는데 그 경우의 수가 너무 많아서 속도가 느려지는 문제를 개선하고자 즉, 수행 시간을 단축하고자 만들어진 알고리즘입니다.

2. 예시 문제

   **[프로그래머스 정수 삼각형](https://school.programmers.co.kr/learn/courses/30/lessons/43105)**

​	<img src="DP.assets/image-20230320152908783.png" alt="image-20230320152908783" style="zoom:33%;" />

3. DP의 목적

   : 메모리를 사용해서 중복 연산을 줄이고 중복 연산을 줄여서 수행 속도를 개선한다.

   - 메모리를 사용한다 -> 배열 혹은 자료구조를 만든다.
   - 중복 연산을 줄인다 -> 연산한 결과를 배열에 담는다.

4. DP 문제 판별법
   - DFS/BFS로 풀 수 는 있지만 경우의 수가 너무 많은 문제
   - 경우의 수들에 중복적인 연산이 많은 경우

5. DP 문제 해결 접근 방법

   - 어떻게 하면 뒤로 돌아가지 않을 수 있을까?
   - 현재 단계까지 연산을 잘했는데, 그 연산을 또 하지 않으려면 어떤 정보를 남겨야 하지?
   - 어떤 식으로 정보를 누적해야 되지?

   -> **즉, DP 삼각형과 같이 나만의 자료구조를 하나 더 만들고 어떤 정보를 담아야 이전 단계로 돌아가지 않을지 고민해보기! DP는 정해진 구조를 그대로 구현하는 하나의 자료 구조가 아니라 수행 시간을 단축할 수 있는 기법이기 때문에 구현 방법이 다양함.**



## 기술면접 질문

1. 동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요.

   : 주어진 문제를 풀기 위해, 문제를 여러 개의 하위 문제로 나누어 푸는 방법을 말합니다.

   동적 계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러번 계산하는 대신 한 번만 계산하고 그 결과를 재활용하는 메모이제이션(Memoization)기법으로 속도를 향상 시킬 수 있습니다.

   

2.  메모이제이션(Memoization)기법은 무엇인가요?

   : 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 재사용함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술을 말합니다.

   

3. 동적 계획법(DP, Dynamic Programming)이 갖는 2가지 조건은 무엇인가요?

   - Overlapping Subproblems 중복되는 부분(작은) 문제

     : 중복되는 부분 문제는 나눠진 부분 문제가 중복되는 경우로 메모이제이션 기법을 사용해 중복 계산을 없앱니다. DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구하기 때문에, 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능해 부분문제가 중복되는 경우에는 사용할 수 없습니다.

   - Optimal Substructure 최적 부분 구조

     : 최적 부분 구조를 가진다는 것은 전체 문제의 최적해가 부분 문제의 최적해들로써 구성된다는 것입니다.

     

4. 일반적인 재귀(Naive Recursion)와 반복의 차이와 DP의 장점에 대해 설명해주세요.

   : 재귀는 함수 내에서 자기 자신을 반복하는 호출이고 반복은 참인 경우 계속하여 반복되는 명령어 블록입니다. DP는 작은 문제의 해를 여러 메모리에 저장해두기 때문에 동일한 계산의 반복을 줄일 수 있어 속도가 빠르다는 장점이 있습니다.

   ![image-20230320161714249](DP.assets/image-20230320161714249.png)

   

5. 피보나치 수열을 구현할 수 있는 알고리즘 3가지를 언급하고 각 시간복잡도를 비교해주세요.

   : 피보나치 수열의 구현 방식에는 재귀, 반복, DP가 있습니다. 재귀문의 시간복잡도는 O(n^2)이고 반복문과 DP를 사용한다면 O(n)입니다. DP의 경우 한 번 값을 구하고 나면 값을 저장하기 때문에 O(1)만에 구할 수 있습니다.



## 참고자료

- [DP설명 블로그](https://hongjw1938.tistory.com/47)
- [DP설명 유튜브](https://youtu.be/0bqfTzpWySY)
- [기술면접 질문지1](https://dev-coco.tistory.com/160)

- [기술면접 질문지2](https://kangsu-2ji.tistory.com/158)
- [기술면접 질문지3](https://sunrise-new-world.tistory.com/22)