

# 퀵정렬

Q. 퀵정렬에 대해 설명하세요.

분할 정복 알고리즘의 하나로, 시간복잡도는 nlogn 이므로 수행 속도가 빠른 편이지만, 이미 정렬된 배열의 경우 시간복잡도는 n2이 됩니다. 과정은 크게 분할, 정복 결합 3단계로 나뉩니다. 분할 단계에선 피벗을 기준으로 왼쪽엔 보다 작은 요소들, 오른쪽엔 큰 요소들로 나눕니다. 정복 단계에선 부분배열들의 정렬을 수행합니다. 결합 단계에선 정렬된 부분 배열들을 하나의 배열에 결합 합니다.

Q-1. 이미 정렬된 배열에서도 성능을 높이려면 어떻게 해야 할까요.

피벗을 정할 때 맨앞의 피벗 혹은 맨 뒤의 피벗을 정한 문제가 생기므로, 중간값을 피벗으로 정하면 해결 할 수 있습니다.

`ps. 수도코드로 작성 후 동작원리를 설명하라 할 수 있으므로 미리 연습해보기`



# 피보나치

Q. 피보나치 수열 구현 방식 세 가지를 말해보시고, 시간복잡도와 공간복잡도를 설명해 주세요

피보나치 수열의 구현 방식 3가지에는 재귀를 통한 구현, 반복문을 통한 구현, 메모라이제이션/동적 계획법을 통한 구현 세가지가 있습니다. 재귀문 통해 구현할 경우 시간복잡도는 O(2^n), 반복문을 통해 구할 경우 O(n), 동적계획법을 통할 경우 O(n) 의 시간 복잡도를 가집니다. 동적계획법을 통할 경우에는 한번 값을 구하고 나면 다음에 다시 구할 때는 O(1)만에 구할수 있다는 점에서 반복문을 통한 방법과 차이가 있습니다.

Q-1. dp로 구현 해보세요.

```python
N # 구하고자 하는 수
dp = [0] * N+1
dp[1] = 1
dp[2] = 1
for i in range(3, N+1):
	dp[i] = dp[i-1] + dp[i-2]

dp[N] # 결과
```



# 이분탐색

이분 탐색은 정렬되어 있는 자료를 두 부분으로 나누어서 탐색하는 알고리즘이며 시간복잡도는 O(logN)를 가진다. 빠른 수행 속도와 간단한 구현이 장점이지만, 정렬된 자료를 사용해야 하는 단점이 있습니다.

수행과정은 5단계로 정리 할 수 있습니다.

1. 정렬을 한다.
2. left와 right로 mid 값을 설정한다.
3. mid와 구하고자 하는 값을 비교한다.
4. 구할 값이 mid보다 크면 -> left = mid + 1 구할 값이 mid보다 낮으면 -> right = mid - 1
5. right < left가 될 때까지 계속 반복한다.