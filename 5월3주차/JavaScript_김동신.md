## Javascript 질문 모음

#### var vs let vs const

|             | var                                                         | let                             | const                           |
| ----------- | ----------------------------------------------------------- | ------------------------------- | ------------------------------- |
| 재할당      | 가능                                                        | 가능                            | 불가                            |
| 재선언      | 가능                                                        | 불가                            | 불가                            |
| 범위(scope) | 함수 외부에서 선언 : 전역<br />함수 내부에서 선언 : 함수 범 | 블록 범위 (=`{}`로 감싸진 범위) | 블록 범위 (=`{}`로 감싸진 범위) |
| 호이스팅    | 발생                                                        | 불가                            | 불가                            |

- 세 변수 선언 방식 모두 호이스팅이 발생하기는 함!
  - 다만, 맨 위로 끌어올려져서 undefined로 초기화되는 var와는 다르게 let과 const는 undefined로 초기화되지 않는다는 차이점이 있음



#### 동등연산자와 일치연산자의 차이는?

- 동등연산자(==)는 자동으로 타입을 변환한 후 비교
- 일치연산자(===)는 타입 변환 없이 값 비교



#### 깊은 복사와 얕은 복사란?

> **얕은 복사**란 객체를 복사할 때 기존 값과 복사된 값이 같은 참조를 가리키고 있는 것을 말합니다.
> 객체 안에 객체가 있을 경우 한 개의 객체라도 기존 변수의 객체를 참조하고 있다면 이를 얕은 복사라고 합니다.
>
> **깊은 복사**된 객체는 객체 안에 객체가 있을 경우에도 원본과의 참조가 완전히 끊어진 객체를 말합니다.

- 자바스크립트의 데이터 저장 방식 때문에 발생하는 현상
- 자바스크립트의 데이터 타입은 기본형과 참조형으로 나뉨
  - 기본형 : 숫자, 문자열, 불리언, null, undefined
  - 참조형 : 객체, 배열, 함수, 날짜, 정규표현식

- 자바스크립트의 데이터 저장 방식

  - 변수를 선언하는 순간 메모리에 공간을 확보하고 공간의 이름을 식별자로 지정
  - 변수에 할당할 값을 저장하기 위한 별도의 메모리공간을 다시 확보
    - 해당 값을 확보한 메모리공간에 저장
    - 이 메모리공간의 주소를 변수 선언시 확보한 메모리 공간의 값으로 저장
  - 이는 데이터 변환을 자유롭게 할 수 있게 함과 동시에 메모리를 더욱 효율적으로 관리하기 위함
  - 즉, 변수란 값이 위치하고 있는 메모리 주소에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자

- 참조형 데이터 선언 시 위 데이터 저장 방식을 재귀로 반복한다

  - 각 프로퍼티마다 위 저장 방식을 반복하는 것
    - 프로퍼티 값이 기본형 데이터일 때 까지

- 이런 와중에 특정 참조형 데이터를 복사한다면 두 값 모두 같은 주소를 가르키게 됨

  - 어느 하나의 데이터가 프로퍼티 값을 변경할 경우, 두 변수가 가리키는 주소값은 달라지지 않고, 두 변수가 가리키고 있는 주소값이 또 가리키고 있는 값만 변경됨
  - 즉, 두 데이터는 결국 동시에 변경이 되버리는 것
    - 이것이 얕은 복사

  ![자바스크립트 데이터 타입 - 메모리와 데이터](https://images.velog.io/images/minidoo/post/b79d12c0-76c1-4003-aa0e-1533e9753fd2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-10-28%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.21.15.png)



#### 불변성을 유지할 수 있는 방법은?

1. Spread Operator를 이용

   ```js
   const obj = { a:1, b:2};
   const newObj = {...obj,c:3};
   console.log(newObj) // {a:1,b:2,c:3}
   ```

2. Object.assign() 메서드 이용

   ```js
   const obj = {a:1,b:2};
   const newObj = Object.assign({},obj,{c:3});
   console.log(newObj); //{a:1,b:2,c:3}
   ```

3. immer 라이브러리 사용

   - 1번과 2번은 객체의 깊이가 깊어질 경우, 코드가 복잡해짐

   ```js
   import produce from 'immer';
   
   const obj = {a:1, b:2};
   const newObj = produce(obj,(draft) => {
     draft.c = 3;
   }); 
   console.log(newObj); // { a: 1, b: 2, c: 3 })
   ```

4. 객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾼다

   - JSON으로 바꿀 수 있는 프로퍼티만 사용 가능

   ```js
   var copyObjectViaJSON = function(target) {
       return JSON.parse(Json.stringify(target))
   }
   ```

   
